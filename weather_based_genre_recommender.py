# -*- coding: utf-8 -*-
"""Weather_Based_Genre_Recommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EfHBfFXX_nlGDDYFz4mObsecYLQfZxhF
"""

import os
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import VGG16
from tensorflow.keras.models import Sequential
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from zipfile import ZipFile
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt
import numpy as np

data_path= "/content/Weather data.zip"

with ZipFile(data_path,'r') as zip: #r=read mode
  zip.extractall()
  print('The Data set has been extracted .')

with ZipFile(data_path,'r') as zip: #r=read mode
  zip.extractall()
  print('The Data set has been extracted .')

IMG_SIZE=256 # resizing image 256 x 256
BATCH_SIZE=32 # 1000/32 = 31.5 . so 32  atch will contain 32 images and last batch will contains 8 images
DATASET_PATH = '/content/dataset'

train_datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    rotation_range=25,
    width_shift_range=0.2,
    height_shift_range=0.2,
    zoom_range=0.3,
    brightness_range=[0.8, 1.2],
    horizontal_flip=True
)

train_generator = train_datagen.flow_from_directory(
    DATASET_PATH,
    target_size=(IMG_SIZE,IMG_SIZE),
    batch_size=BATCH_SIZE,
    class_mode='categorical', # it converts label to one hot encoded format
    subset='training', # it tells the generator to only use the training part of the dataset
    shuffle=True # it randomly shuffle the image each time an epoch starts
)

validation_generator = train_datagen.flow_from_directory(
    DATASET_PATH,
    target_size=(IMG_SIZE,IMG_SIZE),
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    subset='validation',
    shuffle=True
)

base_model = VGG16(include_top=False, weights='imagenet', input_shape=(256, 256, 3))

# Unfreeze last convolutional block
for layer in base_model.layers[-4:]:
    layer.trainable = True

model = Sequential([
    base_model,
    GlobalAveragePooling2D(),
    Dense(256, activation='relu'),
    Dropout(0.4),
    Dense(128, activation='relu'),
    Dropout(0.3),
    Dense(7, activation='softmax')
])

from tensorflow.keras.optimizers import Adam
model.compile(optimizer=Adam(1e-5), loss='categorical_crossentropy', metrics=['accuracy'])

model.summary()

# Early stopping
early_stop = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

# Train
history = model.fit(
    train_generator,
    epochs=10,
    validation_data=validation_generator,
    callbacks=[early_stop]
)

#save the model
model.save("weather_image_detection.h5")

from google.colab import files
files.download('weather_image_detection.h5')

class_labels = ['Cloudy', 'Sunrise', 'hail', 'lightning', 'rain', 'rainbow', 'snow']

img_path = '/content/img 1.jpg'

# Preprocess the image
img = image.load_img(img_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = img_array / 255.0  # Same rescale as training
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimensio

pred = model.predict(img_array)
predicted_index = np.argmax(pred, axis=1)[0]
predicted_label = class_labels[predicted_index]

print(f"Predicted Class: {predicted_label}")
plt.imshow(img)
plt.title(f"Prediction: {predicted_label}")
plt.axis('off')
plt.show()

img_path = '/content/img 2.jpg'

# Preprocess the image
img = image.load_img(img_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = img_array / 255.0  # Same rescale as training
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimensio

pred = model.predict(img_array)
predicted_index = np.argmax(pred, axis=1)[0]
predicted_label = class_labels[predicted_index]

print(f"Predicted Class: {predicted_label}")
plt.imshow(img)
plt.title(f"Prediction: {predicted_label}")
plt.axis('off')
plt.show()

img_path = '/content/img3.jpg'
# Preprocess the image
img = image.load_img(img_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = img_array / 255.0  # Same rescale as training
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimensio
pred = model.predict(img_array)
predicted_index = np.argmax(pred, axis=1)[0]
predicted_label = class_labels[predicted_index]
print(f"Predicted Class: {predicted_label}")
plt.imshow(img)
plt.title(f"Prediction: {predicted_label}")
plt.axis('off')
plt.show()

img_path = '/content/img 4.jpg'
# Preprocess the image
img = image.load_img(img_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = img_array / 255.0  # Same rescale as training
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimensio
pred = model.predict(img_array)
predicted_index = np.argmax(pred, axis=1)[0]
predicted_label = class_labels[predicted_index]
print(f"Predicted Class: {predicted_label}")
plt.imshow(img)
plt.title(f"Prediction: {predicted_label}")
plt.axis('off')
plt.show()

img_path = '/content/img 7.jpg'
# Preprocess the image
img = image.load_img(img_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = img_array / 255.0  # Same rescale as training
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimensio
pred = model.predict(img_array)
predicted_index = np.argmax(pred, axis=1)[0]
predicted_label = class_labels[predicted_index]
print(f"Predicted Class: {predicted_label}")
plt.imshow(img)
plt.title(f"Prediction: {predicted_label}")
plt.axis('off')
plt.show()

img_path = '/content/rain.jpeg'
# Preprocess the image
img = image.load_img(img_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = img_array / 255.0  # Same rescale as training
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimensio
pred = model.predict(img_array)
predicted_index = np.argmax(pred, axis=1)[0]
predicted_label = class_labels[predicted_index]
print(f"Predicted Class: {predicted_label}")
plt.imshow(img)
plt.title(f"Prediction: {predicted_label}")
plt.axis('off')
plt.show()